
# File Tree: Cotizacion-Talleres-Unidos

Generated on: 15/10/2025, 19:50:40
Root path: `c:\xampp\htdocs\Cotizacion-Talleres-Unidos`

```
├── 📁 .git/ 🚫 (auto-hidden)
├── 📁 app/
│   ├── 📁 config/
│   │   └── 🐘 database.php
│   ├── 📁 controllers/
│   │   └── 🐘 DocumentController.php
│   ├── 📁 models/
│   │   └── 🐘 Document.php
│   ├── 📁 services/
│   │   ├── 🐘 DocumentService.php
│   │   └── 🐘 WebhookService.php
│   ├── 📁 uploads/
│   │   ├── 📁 processed/
│   │   └── 📄 .gitkeep
│   ├── 📁 utils/
│   │   └── 🐘 FileConverter.php
│   ├── 📄 .htaccess
│   ├── 🐘 index.php
│   └── ⚙️ php.ini
├── 🐳 Dockerfile
├── 📄 composer.json
├── 🔒 composer.lock 🚫 (auto-hidden)
└── ⚙️ docker-compose.yml
```

---
*Generated by FileTree Pro Extension*



codigos:
index:
<?php
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, Authorization');

// Handle preflight requests
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(200);
    exit();
}

// Composer autoload (if composer was used to install libs)
if (file_exists(__DIR__ . '/vendor/autoload.php')) {
    require_once __DIR__ . '/vendor/autoload.php';
}

require_once 'controllers/DocumentController.php';

$controller = new DocumentController();
$controller->handleRequest();
?>
documentcontroler:
<?php
require_once 'services/DocumentService.php';
require_once 'models/Document.php';

class DocumentController {
    private $documentService;
    private $uploadDir;

    public function __construct() {
        $this->documentService = new DocumentService();
        $this->uploadDir = __DIR__ . '/../uploads/';
    }

    public function handleRequest() {
        $method = $_SERVER['REQUEST_METHOD'];
        $uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
        $path = str_replace('/index.php', '', $uri);

        try {
            switch ($path) {
                case '/api/documents':
                    if ($method === 'POST') {
                        $this->uploadAndProcessDocument();
                    } elseif ($method === 'GET') {
                        $this->getDocuments();
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;
                
                case '/api/documents/bin':
                    if ($method === 'POST') {
                        $this->uploadBinaryDocument();
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;

                case '/api/documents/manual':
                    if ($method === 'POST') {
                        $this->processDocument();
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;
                
                // NUEVO ENDPOINT: Transformar y devolver archivo multipart
                case '/api/documents/transform':
                    if ($method === 'POST') {
                        $this->transformAndReturnDocument();
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;

                // NUEVO ENDPOINT: Transformar y devolver archivo binario
                case '/api/documents/transform/bin':
                    if ($method === 'POST') {
                        $this->transformAndReturnBinaryDocument();
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;
                
                case '/api/health':
                    if ($method === 'GET') {
                        $this->healthCheck();
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;

                // ENDPOINT: Recepción de .zip o .rar, extracción y procesamiento
                case '/api/uploads-ziprar':
                    if ($method === 'POST') {
                        $this->uploadArchiveAndProcess();
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;
                
                case '/':
                    if ($method === 'GET') {
                        $this->sendResponse(200, [
                            'message' => 'Document Processing API - Automatic Conversion',
                            'endpoints' => [
                                'POST /api/documents - Upload and auto-process document (multipart)',
                                'POST /api/documents/bin - Upload and auto-process document (binary)',
                                'POST /api/documents/transform - Transform document and return (multipart)',
                                'POST /api/documents/transform/bin - Transform document and return (binary)',
                                'GET /api/health - Health check',
                                'POST /api/documents/manual - Manual processing (deprecated)'
                            ]
                        ]);
                    } else {
                        $this->sendError(405, 'Method not allowed');
                    }
                    break;
                
                default:
                    $this->sendError(404, 'Endpoint not found');
            }
        } catch (Exception $e) {
            $this->sendError(500, 'Internal server error: ' . $e->getMessage());
        }
    }

    private function uploadAndProcessDocument() {
        if (!isset($_FILES['document'])) {
            $this->sendError(400, 'No document provided');
            return;
        }

        $file = $_FILES['document'];
        $uploadResult = $this->documentService->uploadDocument($file);

        if (!$uploadResult['success']) {
            $this->sendError(400, $uploadResult['message']);
            return;
        }

        // Procesar automáticamente
        $processResult = $this->documentService->processDocument($uploadResult['document']['file_path']);

        if ($processResult['success']) {
            $this->sendResponse(200, [
                'success' => true,
                'upload' => $uploadResult['document'],
                'processing' => [
                    'processed_file' => $processResult['processed_file'],
                    'webhook_sent' => $processResult['webhook_sent']
                ],
                'webhook_url' => $processResult['webhook_url'],
                'message' => 'Document uploaded, processed and sent to webhook automatically'
            ]);
        } else {
            $this->sendError(400, 'Processing failed: ' . $processResult['message']);
        }
    }

    private function uploadBinaryDocument() {
        $input = file_get_contents('php://input');
        
        if (empty($input)) {
            $this->sendError(400, 'No document data provided');
            return;
        }
        
        // Obtener nombre del archivo del header o usar uno por defecto
        $filename = $_SERVER['HTTP_X_FILENAME'] ?? ('document_' . uniqid());
        
        // Asegurar que tenga extensión
        if (pathinfo($filename, PATHINFO_EXTENSION) === '') {
            // Intentar determinar el tipo de archivo por su contenido
            $finfo = new finfo(FILEINFO_MIME_TYPE);
            $mimeType = $finfo->buffer($input);
            
            $extensions = [
                'application/pdf' => '.pdf',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => '.docx',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' => '.xlsx',
                'application/vnd.ms-excel.sheet.macroEnabled.12' => '.xlsm'
            ];
            
            $extension = $extensions[$mimeType] ?? '.bin';
            $filename .= $extension;
        }
        
        $filePath = $this->uploadDir . $filename;
        
        // Validar tamaño (50MB máximo)
        if (strlen($input) > 50 * 1024 * 1024) {
            $this->sendError(400, 'File size exceeds 50MB limit');
            return;
        }
        
        // Validar tipo de archivo
        $allowedExtensions = ['pdf', 'docx', 'xlsx', 'xlsm'];
        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
        if (!in_array($fileExtension, $allowedExtensions)) {
            $this->sendError(400, 'File type not allowed. Allowed types: ' . implode(', ', $allowedExtensions));
            return;
        }
        
        // Guardar el archivo binario
        if (file_put_contents($filePath, $input) === false) {
            $this->sendError(500, 'Failed to save document');
            return;
        }
        
        // Crear un array similar al $_FILES para mantener consistencia
        $fileInfo = [
            'name' => $filename,
            'type' => mime_content_type($filePath),
            'tmp_name' => $filePath,
            'error' => 0,
            'size' => strlen($input)
        ];
        
        // Usar el mismo método de procesamiento que uploadAndProcessDocument
        $uploadResult = $this->documentService->uploadDocument($fileInfo, true);
        
        if (!$uploadResult['success']) {
            $this->sendError(400, $uploadResult['message']);
            return;
        }
        
        // Procesar automáticamente
        $processResult = $this->documentService->processDocument($uploadResult['document']['file_path']);
        
        if ($processResult['success']) {
            $this->sendResponse(200, [
                'success' => true,
                'upload' => $uploadResult['document'],
                'processing' => [
                    'processed_file' => $processResult['processed_file'],
                    'webhook_sent' => $processResult['webhook_sent']
                ],
                'webhook_url' => $processResult['webhook_url'],
                'message' => 'Document uploaded, processed and sent to webhook automatically'
            ]);
        } else {
            $this->sendError(400, 'Processing failed: ' . $processResult['message']);
        }
    }

    // NUEVO MÉTODO: Transformar y devolver archivo multipart
    private function transformAndReturnDocument() {
        if (!isset($_FILES['document'])) {
            $this->sendError(400, 'No document provided');
            return;
        }

        $file = $_FILES['document'];
        $uploadResult = $this->documentService->uploadDocument($file);

        if (!$uploadResult['success']) {
            $this->sendError(400, $uploadResult['message']);
            return;
        }

        // Procesar archivo (convertir)
        $processResult = $this->documentService->processDocumentForReturn($uploadResult['document']['file_path']);

        if ($processResult['success']) {
            // Devolver el archivo transformado
            $this->returnProcessedFile($processResult['processed_file']);
        } else {
            $this->sendError(400, 'Processing failed: ' . $processResult['message']);
        }
    }

    // NUEVO MÉTODO: Transformar y devolver archivo binario
    private function transformAndReturnBinaryDocument() {
        $input = file_get_contents('php://input');
        
        if (empty($input)) {
            $this->sendError(400, 'No document data provided');
            return;
        }
        
        // Obtener nombre del archivo del header o usar uno por defecto
        $filename = $_SERVER['HTTP_X_FILENAME'] ?? ('document_' . uniqid());
        
        // Asegurar que tenga extensión
        if (pathinfo($filename, PATHINFO_EXTENSION) === '') {
            // Intentar determinar el tipo de archivo por su contenido
            $finfo = new finfo(FILEINFO_MIME_TYPE);
            $mimeType = $finfo->buffer($input);
            
            $extensions = [
                'application/pdf' => '.pdf',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => '.docx',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' => '.xlsx',
                'application/vnd.ms-excel.sheet.macroEnabled.12' => '.xlsm'
            ];
            
            $extension = $extensions[$mimeType] ?? '.bin';
            $filename .= $extension;
        }
        
        $filePath = $this->uploadDir . $filename;
        
        // Validar tamaño (50MB máximo)
        if (strlen($input) > 50 * 1024 * 1024) {
            $this->sendError(400, 'File size exceeds 50MB limit');
            return;
        }
        
        // Validar tipo de archivo
        $allowedExtensions = ['pdf', 'docx', 'xlsx', 'xlsm'];
        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
        if (!in_array($fileExtension, $allowedExtensions)) {
            $this->sendError(400, 'File type not allowed. Allowed types: ' . implode(', ', $allowedExtensions));
            return;
        }
        
        // Guardar el archivo binario
        if (file_put_contents($filePath, $input) === false) {
            $this->sendError(500, 'Failed to save document');
            return;
        }
        
        // Crear un array similar al $_FILES para mantener consistencia
        $fileInfo = [
            'name' => $filename,
            'type' => mime_content_type($filePath),
            'tmp_name' => $filePath,
            'error' => 0,
            'size' => strlen($input)
        ];
        
        $uploadResult = $this->documentService->uploadDocument($fileInfo, true);
        
        if (!$uploadResult['success']) {
            $this->sendError(400, $uploadResult['message']);
            return;
        }
        
        // Procesar archivo (convertir)
        $processResult = $this->documentService->processDocumentForReturn($uploadResult['document']['file_path']);

        if ($processResult['success']) {
            // Devolver el archivo transformado en binario
            $this->returnProcessedFileBinary($processResult['processed_file']);
        } else {
            $this->sendError(400, 'Processing failed: ' . $processResult['message']);
        }
    }

    // Método para devolver archivo transformado
    private function returnProcessedFile($processedFilePath) {
        if (!file_exists($processedFilePath)) {
            $this->sendError(404, 'Processed file not found');
            return;
        }

        // Establecer headers para la descarga
        $mimeType = mime_content_type($processedFilePath);
        $fileName = basename($processedFilePath);
        
        header('Content-Type: ' . $mimeType);
        header('Content-Disposition: attachment; filename="' . $fileName . '"');
        header('Content-Length: ' . filesize($processedFilePath));
        header('Cache-Control: no-cache, must-revalidate');
        header('Expires: 0');
        
        // Enviar el archivo
        readfile($processedFilePath);
        exit;
    }

    // Método para devolver archivo transformado en binario
    private function returnProcessedFileBinary($processedFilePath) {
        if (!file_exists($processedFilePath)) {
            $this->sendError(404, 'Processed file not found');
            return;
        }

        // Establecer headers para devolver binario
        $mimeType = mime_content_type($processedFilePath);
        $fileName = basename($processedFilePath);
        
        header('Content-Type: application/octet-stream');
        header('Content-Disposition: attachment; filename="' . $fileName . '"');
        header('Content-Length: ' . filesize($processedFilePath));
        header('X-File-Name: ' . $fileName);
        header('X-File-Type: ' . $mimeType);
        
        // Enviar el archivo binario
        readfile($processedFilePath);
        exit;
    }

    private function processDocument() {
        $input = json_decode(file_get_contents('php://input'), true);
        
        if (!$input || !isset($input['document_id'])) {
            $this->sendError(400, 'Document ID is required');
            return;
        }

        $result = $this->documentService->processDocument($input['document_id']);

        if ($result['success']) {
            $this->sendResponse(200, $result);
        } else {
            $this->sendError(400, $result['message']);
        }
    }

    private function getDocuments() {
        $documents = $this->documentService->getAllDocuments();
        $this->sendResponse(200, ['documents' => $documents]);
    }

    // Nuevo: recibir archivo .zip o .rar, extraer y procesar documentos internos
    private function uploadArchiveAndProcess() {
        if (!isset($_FILES['archive'])) {
            $this->sendError(400, 'No archive provided');
            return;
        }

        $file = $_FILES['archive'];

        // Validar extensión
        $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
        $allowed = ['zip', 'rar'];
        if (!in_array($ext, $allowed)) {
            $this->sendError(400, 'Archive type not allowed. Allowed: zip, rar');
            return;
        }

        // Limitar tamaño (por ejemplo 100MB)
        $maxBytes = 100 * 1024 * 1024;
        $fileSize = $file['size'];
        if ($fileSize > $maxBytes) {
            $this->sendError(400, 'Archive size exceeds 100MB limit');
            return;
        }

        // Guardar temporalmente en uploads
        $tmpName = uniqid() . '_' . basename($file['name']);
        $destPath = $this->uploadDir . $tmpName;

        if (!move_uploaded_file($file['tmp_name'], $destPath)) {
            $this->sendError(500, 'Failed to save uploaded archive');
            return;
        }

        // Delegar al servicio para extraer y procesar
        $result = $this->documentService->processArchive($destPath);

        if ($result['success']) {
            $this->sendResponse(200, $result);
        } else {
            $this->sendError(400, $result['message']);
        }
    }

    private function healthCheck() {
        $this->sendResponse(200, [
            'status' => 'healthy',
            'timestamp' => date('Y-m-d H:i:s'),
            'version' => '1.0.0'
        ]);
    }

    private function sendResponse($statusCode, $data) {
        http_response_code($statusCode);
        echo json_encode($data);
    }

    private function sendError($statusCode, $message) {
        http_response_code($statusCode);
        echo json_encode([
            'success' => false,
            'message' => $message
        ]);
    }
}
?>
document:
<?php
class Document {
    public $id;
    public $original_name;
    public $file_path;
    public $file_type;
    public $file_size;
    public $status;
    public $processed_path;
    public $created_at;
    public $updated_at;

    public function __construct($data = []) {
        foreach ($data as $key => $value) {
            if (property_exists($this, $key)) {
                $this->$key = $value;
            }
        }
    }

    public function toArray() {
        return [
            'id' => $this->id,
            'original_name' => $this->original_name,
            'file_path' => $this->file_path,
            'file_type' => $this->file_type,
            'file_size' => $this->file_size,
            'status' => $this->status,
            'processed_path' => $this->processed_path,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at
        ];
    }
}
?>
documenservice:
<?php
require_once 'utils/FileConverter.php';
require_once 'services/WebhookService.php';
require_once 'models/Document.php';

class DocumentService {
    private $uploadDir;
    private $processedDir;
    private $fileConverter;
    private $webhookService;

    public function __construct() {
        $this->uploadDir = __DIR__ . '/../uploads/';
        $this->processedDir = __DIR__ . '/../uploads/processed/';
        $this->fileConverter = new FileConverter();
        $this->webhookService = new WebhookService();

        // Create directories if they don't exist
        if (!is_dir($this->uploadDir)) {
            mkdir($this->uploadDir, 0755, true);
        }
        if (!is_dir($this->processedDir)) {
            mkdir($this->processedDir, 0755, true);
        }
    }

    public function uploadDocument($file, $alreadySaved = false) {
        try {
            // Validate file
            if (!$alreadySaved && $file['error'] !== UPLOAD_ERR_OK) {
                throw new Exception('File upload error: ' . $file['error']);
            }

            // Check file size (50MB limit)
            $fileSize = $alreadySaved ? filesize($file['tmp_name']) : $file['size'];
            if ($fileSize > 50 * 1024 * 1024) {
                throw new Exception('File size exceeds 50MB limit');
            }

            // Get file info
            $fileName = $alreadySaved ? $file['name'] : $file['name'];
            $fileType = strtolower(pathinfo($fileName, PATHINFO_EXTENSION));
            $allowedTypes = ['pdf', 'docx', 'xlsx', 'xlsm'];
            
            if (!in_array($fileType, $allowedTypes)) {
                throw new Exception('File type not allowed. Allowed types: ' . implode(', ', $allowedTypes));
            }

            $filePath = $alreadySaved ? $file['tmp_name'] : '';

            if (!$alreadySaved) {
                // Generate unique filename
                $filename = uniqid() . '_' . $file['name'];
                $filePath = $this->uploadDir . $filename;

                // Move uploaded file
                if (!move_uploaded_file($file['tmp_name'], $filePath)) {
                    throw new Exception('Failed to move uploaded file');
                }
            }

            // Create document record
            $document = new Document([
                'original_name' => $fileName,
                'file_path' => $filePath,
                'file_type' => $fileType,
                'file_size' => $fileSize,
                'status' => 'uploaded',
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ]);

            return [
                'success' => true,
                'document' => $document->toArray(),
                'message' => 'Document uploaded successfully'
            ];

        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => $e->getMessage()
            ];
        }
    }

    public function processDocument($documentId) {
        try {
            // For simplicity, we'll use the file path as ID
            // In a real application, you would query a database
            $filePath = $documentId;
            
            if (!file_exists($filePath)) {
                throw new Exception('Document not found');
            }

            $fileType = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));
            $processedPath = '';

            switch ($fileType) {
                case 'pdf':
                    $processedPath = $this->fileConverter->convertPdfToPng($filePath);
                    break;
                case 'docx':
                    $processedPath = $this->fileConverter->convertDocxToPdf($filePath);
                    break;
                case 'xlsx':
                case 'xlsm':
                    $processedPath = $this->fileConverter->convertExcelToPdf($filePath);
                    break;
                default:
                    throw new Exception('Unsupported file type');
            }

            // Verificar que el archivo procesado exista
            if (!file_exists($processedPath)) {
                throw new Exception('Processed file was not created: ' . $processedPath);
            }

            // Send to webhook with absolute paths
            $webhookResult = $this->webhookService->sendToWebhook([
                'original_file' => $filePath,
                'processed_file' => $processedPath,
                'file_type' => $fileType,
                'timestamp' => date('Y-m-d H:i:s')
            ]);

            return [
                'success' => true,
                'processed_file' => $processedPath,
                'webhook_sent' => $webhookResult,
                'webhook_url' => $webhookResult['webhook_url'],
                'message' => 'Document processed successfully'
            ];

        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => $e->getMessage()
            ];
        }
    }

    // NUEVO MÉTODO: Procesar documento y devolver ruta del archivo transformado
    public function processDocumentForReturn($documentId) {
        try {
            // For simplicity, we'll use the file path as ID
            // In a real application, you would query a database
            $filePath = $documentId;
            
            if (!file_exists($filePath)) {
                throw new Exception('Document not found');
            }

            $fileType = strtolower(pathinfo($filePath, PATHINFO_EXTENSION));
            $processedPath = '';

            switch ($fileType) {
                case 'pdf':
                    $processedPath = $this->fileConverter->convertPdfToPng($filePath);
                    break;
                case 'docx':
                    $processedPath = $this->fileConverter->convertDocxToPdf($filePath);
                    break;
                case 'xlsx':
                case 'xlsm':
                    $processedPath = $this->fileConverter->convertExcelToPdf($filePath);
                    break;
                default:
                    throw new Exception('Unsupported file type');
            }

            // Verificar que el archivo procesado exista
            if (!file_exists($processedPath)) {
                throw new Exception('Processed file was not created: ' . $processedPath);
            }

            return [
                'success' => true,
                'processed_file' => $processedPath,
                'message' => 'Document processed successfully'
            ];

        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => $e->getMessage()
            ];
        }
    }

    public function getAllDocuments() {
        $documents = [];
        $files = glob($this->uploadDir . '*');
        
        foreach ($files as $file) {
            if (is_file($file)) {
                $documents[] = [
                    'id' => $file,
                    'name' => basename($file),
                    'size' => filesize($file),
                    'type' => mime_content_type($file),
                    'modified' => date('Y-m-d H:i:s', filemtime($file))
                ];
            }
        }
        
        return $documents;
    }

    // Nuevo: Procesar un archivo .zip o .rar: extraer y procesar los archivos internos
    public function processArchive($archivePath) {
        try {
            if (!file_exists($archivePath) || !is_readable($archivePath)) {
                throw new Exception('Archive not found or not readable');
            }

            // Space check: optional
            $tempDir = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'ua_extract_' . uniqid();
            if (!mkdir($tempDir, 0755, true) && !is_dir($tempDir)) {
                throw new Exception('Failed to create temp dir: ' . $tempDir);
            }

            // Use UnifiedArchive to open and extract
            $archive = \wapmorgan\UnifiedArchive\UnifiedArchive::open($archivePath);

            // Check extracted size vs free space
            $needed = $archive->getOriginalSize();
            if (disk_free_space($tempDir) !== false && disk_free_space($tempDir) < $needed) {
                // proceed but warn
                // throw new Exception('Not enough disk space to extract archive');
            }

            $extractedCount = $archive->extract($tempDir);

            // Allowed file types inside archive
            $allowed = ['pdf', 'docx', 'xlsx', 'xlsm'];

            $processedFiles = [];

            // Iterate extracted files
            $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($tempDir));
            foreach ($it as $file) {
                if ($file->isFile()) {
                    $ext = strtolower(pathinfo($file->getFilename(), PATHINFO_EXTENSION));
                    if (!in_array($ext, $allowed)) {
                        continue;
                    }

                    // Respect same size limits (100MB per file)
                    if ($file->getSize() > 100 * 1024 * 1024) {
                        continue; // skip too large files
                    }

                    // Build a fake $_FILES-like array to reuse uploadDocument
                    $fileInfo = [
                        'name' => $file->getFilename(),
                        'type' => mime_content_type($file->getPathname()),
                        'tmp_name' => $file->getPathname(),
                        'error' => 0,
                        'size' => $file->getSize()
                    ];

                    // Upload (already saved), so flag alreadySaved=true
                    $uploadResult = $this->uploadDocument($fileInfo, true);
                    if (!$uploadResult['success']) {
                        // Skip and continue
                        continue;
                    }

                    // Process the uploaded file
                    $proc = $this->processDocument($uploadResult['document']['file_path']);
                    if ($proc['success']) {
                        $processedFiles[] = [
                            'original' => $uploadResult['document']['file_path'],
                            'processed' => $proc['processed_file']
                        ];
                    }
                }
            }

            // Cleanup temp dir
            $this->rrmdir($tempDir);

            return [
                'success' => true,
                'extracted_count' => $extractedCount,
                'processed_files' => $processedFiles,
                'message' => 'Archive processed'
            ];

        } catch (Exception $e) {
            return [
                'success' => false,
                'message' => 'Archive processing failed: ' . $e->getMessage()
            ];
        }
    }
}
?>
webhookservice:
<?php
class WebhookService {
    private $webhookUrl;

    public function __construct() {
        $this->webhookUrl = getenv('WEBHOOK_URL') ?: 'https://your-n8n-webhook-url.com/webhook ';
    }

    public function sendToWebhook($data) {
        try {
            // Leer el contenido del archivo procesado
            $processedFilePath = $data['processed_file'];
            $fileContent = '';
            $fileName = '';
            $fileSize = 0;
            $mimeType = '';
            
            if (file_exists($processedFilePath)) {
                $fileContent = file_get_contents($processedFilePath);
                $fileName = basename($processedFilePath);
                $fileSize = filesize($processedFilePath);
                $mimeType = mime_content_type($processedFilePath);
            } else {
                throw new Exception('Processed file not found: ' . $processedFilePath);
            }

            // Crear una solicitud multipart/form-data con solo el archivo binario
            $boundary = '----WebKitFormBoundary' . uniqid();
            $postData = '';

            // Agregar metadatos como campos individuales
            $metadata = [
                'original_file' => $data['original_file'],
                'processed_file' => $data['processed_file'],
                'file_type' => $data['file_type'],
                'timestamp' => $data['timestamp'],
                'file_name' => $fileName,
                'file_size' => $fileSize,
                'mime_type' => $mimeType
            ];

            foreach ($metadata as $key => $value) {
                $postData .= "--{$boundary}\r\n";
                $postData .= "Content-Disposition: form-data; name=\"{$key}\"\r\n\r\n";
                $postData .= "{$value}\r\n";
            }

            // Agregar archivo binario
            $postData .= "--{$boundary}\r\n";
            $postData .= "Content-Disposition: form-data; name=\"file\"; filename=\"{$fileName}\"\r\n";
            $postData .= "Content-Type: {$mimeType}\r\n\r\n";
            $postData .= $fileContent . "\r\n";

            $postData .= "--{$boundary}--\r\n";

            $ch = curl_init($this->webhookUrl);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);
            curl_setopt($ch, CURLOPT_HTTPHEADER, [
                'Content-Type: multipart/form-data; boundary=' . $boundary,
                'Content-Length: ' . strlen($postData)
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            $error = curl_error($ch);
            curl_close($ch);
            
            if ($error) {
                throw new Exception('cURL Error: ' . $error);
            }
            
            return [
                'success' => $httpCode >= 200 && $httpCode < 300,
                'http_code' => $httpCode,
                'response' => $response,
                'webhook_url' => $this->webhookUrl  // ← Añadido

            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage(),
                'webhook_url' => $this->webhookUrl  // ← Añadido

            ];
        }
    }
}
?>
fileconvert:
<?php
class FileConverter {
    private $processedDir;

    public function __construct() {
        $this->processedDir = __DIR__ . '/../uploads/processed/';
        if (!is_dir($this->processedDir)) {
            mkdir($this->processedDir, 0777, true);
        }
    }

    public function convertPdfToPng($pdfPath) {
        try {
            // Verificar que el archivo exista y sea legible
            if (!file_exists($pdfPath) || !is_readable($pdfPath)) {
                throw new Exception('PDF file does not exist or is not readable: ' . $pdfPath);
            }

            // Contar el número de páginas en el PDF
            $command = "pdfinfo " . escapeshellarg($pdfPath) . " 2>&1";
            exec($command, $output, $returnCode);
            
            if ($returnCode !== 0) {
                throw new Exception('Failed to get PDF info. Command: ' . $command . ' Output: ' . implode("\n", $output));
            }
            
            $pages = 0;
            foreach ($output as $line) {
                if (preg_match('/^Pages:\s+(\d+)/', $line, $matches)) {
                    $pages = (int)$matches[1];
                    break;
                }
            }
            
            // Si el PDF tiene más de 1 página, devolver el archivo original sin cambios
            if ($pages > 1) {
                // Generar nuevo nombre con ID para mantener consistencia
                $originalNameWithoutExt = pathinfo($pdfPath, PATHINFO_FILENAME);
                $uniqueId = uniqid();
                $newFileName = $uniqueId . '-' . $originalNameWithoutExt . '.pdf';
                $outputPath = $this->processedDir . $newFileName;
                
                // Copiar el archivo original al directorio de procesados
                if (!copy($pdfPath, $outputPath)) {
                    throw new Exception('Failed to copy multi-page PDF to processed directory');
                }
                
                return $outputPath;
            }
            
            // Si el PDF tiene solo 1 página, convertir a PNG
            $originalNameWithoutExt = pathinfo($pdfPath, PATHINFO_FILENAME);
            $uniqueId = uniqid();
            $newFileName = $uniqueId . '-' . $originalNameWithoutExt . '.png';
            $outputPath = $this->processedDir . $newFileName;
            
            // Convert first page of PDF to PNG
            $command = "pdftoppm -png -f 1 -l 1 " . escapeshellarg($pdfPath) . " " . escapeshellarg($this->processedDir . $uniqueId . '-' . $originalNameWithoutExt) . " 2>&1";
            exec($command, $output, $returnCode);
            
            if ($returnCode !== 0) {
                throw new Exception('Failed to convert PDF to PNG. Command: ' . $command . ' Output: ' . implode("\n", $output));
            }
            
            // Verificar que el archivo se creó (pdftoppm puede crear con sufijo -1)
            $finalPath = $this->processedDir . $uniqueId . '-' . $originalNameWithoutExt . '-1.png';
            if (file_exists($finalPath)) {
                rename($finalPath, $outputPath);
            }
            
            if (!file_exists($outputPath)) {
                throw new Exception('PNG file was not created');
            }
            
            return $outputPath; // ← Devuelve la ruta absoluta
        } catch (Exception $e) {
            throw new Exception('PDF conversion failed: ' . $e->getMessage());
        }
    }

    public function convertDocxToPdf($docxPath) {
        try {
            // Verificar que el archivo exista y sea legible
            if (!file_exists($docxPath) || !is_readable($docxPath)) {
                throw new Exception('DOCX file does not exist or is not readable: ' . $docxPath);
            }

            // Obtener el nombre base del archivo original (sin extensión)
            $originalNameWithoutExt = pathinfo($docxPath, PATHINFO_FILENAME);
            
            // Generar ID único
            $uniqueId = uniqid();
            
            // Crear nuevo nombre: ID-OriginalName.pdf
            $newFileName = $uniqueId . '-' . $originalNameWithoutExt . '.pdf';
            $outputPath = $this->processedDir . $newFileName;
            
            // Copiar el archivo a un directorio temporal con permisos correctos
            $tempDir = '/tmp/libreoffice_' . uniqid();
            if (!is_dir($tempDir)) {
                mkdir($tempDir, 0777, true);
            }
            
            $tempFile = $tempDir . '/' . basename($docxPath);
            if (!copy($docxPath, $tempFile)) {
                $this->rrmdir($tempDir);
                throw new Exception('Failed to copy file to temporary directory');
            }
            
            // Asegurar permisos correctos
            chmod($tempFile, 0644);
            
            // Convert DOCX to PDF using LibreOffice with corrected command
            $command = "HOME=/tmp timeout 60 xvfb-run --auto-servernum --server-args='-screen 0 1024x768x24' libreoffice --headless --invisible --nodefault --nofirststartwizard --nolockcheck --nologo --norestore --convert-to pdf --outdir " . escapeshellarg($tempDir) . " " . escapeshellarg($tempFile) . " 2>&1";
            exec($command, $output, $returnCode);
            
            // Debug: mostrar salida de LibreOffice
            error_log("LibreOffice command: " . $command);
            error_log("LibreOffice output: " . implode("\n", $output));
            error_log("Return code: " . $returnCode);
            
            // Mover el archivo convertido al directorio final con el nuevo nombre
            $originalConvertedName = pathinfo($docxPath, PATHINFO_FILENAME) . '.pdf';
            $convertedFile = $tempDir . '/' . $originalConvertedName;
            
            if (file_exists($convertedFile)) {
                // Renombrar al nuevo nombre con ID
                rename($convertedFile, $outputPath);
                // Limpiar directorio temporal
                $this->rrmdir($tempDir);
            } else {
                // Limpiar directorio temporal
                $this->rrmdir($tempDir);
                throw new Exception('Failed to convert DOCX to PDF. LibreOffice could not create output file. Command: ' . $command . ' Output: ' . implode("\n", $output) . ' Return code: ' . $returnCode);
            }
            
            if (!file_exists($outputPath)) {
                throw new Exception('PDF file was not created');
            }
            
            return $outputPath; // ← Devuelve la ruta absoluta
        } catch (Exception $e) {
            throw new Exception('DOCX to PDF conversion failed: ' . $e->getMessage());
        }
    }

    public function convertExcelToPdf($excelPath) {
        try {
            // Verificar que el archivo exista y sea legible
            if (!file_exists($excelPath) || !is_readable($excelPath)) {
                throw new Exception('Excel file does not exist or is not readable: ' . $excelPath);
            }

            // Obtener el nombre base del archivo original (sin extensión)
            $originalNameWithoutExt = pathinfo($excelPath, PATHINFO_FILENAME);
            
            // Generar ID único
            $uniqueId = uniqid();
            
            // Crear nuevo nombre: ID-OriginalName.pdf
            $newFileName = $uniqueId . '-' . $originalNameWithoutExt . '.pdf';
            $outputPath = $this->processedDir . $newFileName;
            
            // Copiar el archivo a un directorio temporal con permisos correctos
            $tempDir = '/tmp/libreoffice_' . uniqid();
            if (!is_dir($tempDir)) {
                mkdir($tempDir, 0777, true);
            }
            
            $tempFile = $tempDir . '/' . basename($excelPath);
            if (!copy($excelPath, $tempFile)) {
                $this->rrmdir($tempDir);
                throw new Exception('Failed to copy file to temporary directory');
            }
            
            // Asegurar permisos correctos
            chmod($tempFile, 0644);
            
            // Convert Excel to PDF using LibreOffice
            $command = "HOME=/tmp timeout 60 xvfb-run --auto-servernum --server-args='-screen 0 1024x768x24' libreoffice --headless --invisible --nodefault --nofirststartwizard --nolockcheck --nologo --norestore --convert-to pdf --outdir " . escapeshellarg($tempDir) . " " . escapeshellarg($tempFile) . " 2>&1";
            exec($command, $output, $returnCode);
            
            // Mover el archivo convertido al directorio final con el nuevo nombre
            $originalConvertedName = pathinfo($excelPath, PATHINFO_FILENAME) . '.pdf';
            $convertedFile = $tempDir . '/' . $originalConvertedName;
            
            if (file_exists($convertedFile)) {
                // Renombrar al nuevo nombre con ID
                rename($convertedFile, $outputPath);
                // Limpiar directorio temporal
                $this->rrmdir($tempDir);
            } else {
                // Limpiar directorio temporal
                $this->rrmdir($tempDir);
                throw new Exception('Failed to convert Excel to PDF. LibreOffice output: ' . implode("\n", $output) . ' Return code: ' . $returnCode);
            }
            
            if (!file_exists($outputPath)) {
                throw new Exception('PDF file was not created');
            }
            
            return $outputPath; // ← Devuelve la ruta absoluta
        } catch (Exception $e) {
            throw new Exception('Excel to PDF conversion failed: ' . $e->getMessage());
        }
    }

    // Función auxiliar para eliminar directorios recursivamente
    private function rrmdir($dir) {
        if (is_dir($dir)) {
            $objects = scandir($dir);
            foreach ($objects as $object) {
                if ($object != "." && $object != "..") {
                    if (is_dir($dir . "/" . $object))
                        $this->rrmdir($dir . "/" . $object);
                    else
                        unlink($dir . "/" . $object);
                }
            }
            rmdir($dir);
        }
    }
}
?>

dockerfile:
FROM php:8.1-apache

# Install system dependencies including xvfb for headless LibreOffice
RUN apt-get update && apt-get install -y \
    libzip-dev \
    libpng-dev \
    libjpeg-dev \
    libfreetype6-dev \
    ghostscript \
    libreoffice \
    libreoffice-core \
    libreoffice-common \
    libreoffice-writer \
    libreoffice-calc \
    poppler-utils \
    xvfb \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install PHP extensions
RUN docker-php-ext-configure gd --with-freetype --with-jpeg
RUN docker-php-ext-install -j$(nproc) gd zip pdo_mysql

# Enable Apache modules
RUN a2enmod rewrite


# Copy custom PHP configuration
COPY ./app/php.ini /usr/local/etc/php/conf.d/custom.ini
# Configure Apache to serve files from /var/www/html
COPY ./app /var/www/html

# Create directories with proper permissions
RUN mkdir -p /tmp/libreoffice /var/www/.config/libreoffice
RUN chown -R www-data:www-data /var/www/html /tmp/libreoffice
RUN chmod -R 777 /tmp

# Expose port
EXPOSE 80

# Start Apache
CMD ["apache2-foreground"]